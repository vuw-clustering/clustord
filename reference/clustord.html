<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Likelihood-based clustering using Ordered Stereotype Models (OSM), Proportional Odds Models (POM) or Binary Models — clustord • clustord</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Likelihood-based clustering using Ordered Stereotype Models (OSM), Proportional Odds Models (POM) or Binary Models — clustord"><meta name="description" content="Likelihood-based clustering with parameters fitted using the EM algorithm.
You can perform clustering on rows or columns of a data matrix, or biclustering
on both rows and columns simultaneously. You can include any number of
covariates for rows and covariates for columns.
Ordinal models used in the package are Ordered Stereotype Model (OSM),
Proportional Odds Model (POM) and a dedicated Binary Model for binary data."><meta property="og:description" content="Likelihood-based clustering with parameters fitted using the EM algorithm.
You can perform clustering on rows or columns of a data matrix, or biclustering
on both rows and columns simultaneously. You can include any number of
covariates for rows and covariates for columns.
Ordinal models used in the package are Ordered Stereotype Model (OSM),
Proportional Odds Model (POM) and a dedicated Binary Model for binary data."></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">clustord</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.3.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/clustordConvergence.html">`clustord Convergence Tutorial</a></li>
    <li><a class="dropdown-item" href="../articles/clustordOrdinalModels.html">`clustord` Ordinal Models</a></li>
    <li><a class="dropdown-item" href="../articles/clustordStructureSummary.html">`clustord` Structure Summary</a></li>
    <li><a class="dropdown-item" href="../articles/clustordTutorial.html">`clustord` Tutorial</a></li>
    <li><a class="dropdown-item" href="../articles/RegressionwithOSM.html">Regression with the Ordered Stereotype Model (OSM)</a></li>
  </ul></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Likelihood-based clustering using Ordered Stereotype Models (OSM), Proportional Odds Models (POM) or Binary Models</h1>

      <div class="d-none name"><code>clustord.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Likelihood-based clustering with parameters fitted using the EM algorithm.
You can perform clustering on rows or columns of a data matrix, or biclustering
on both rows and columns simultaneously. You can include any number of
covariates for rows and covariates for columns.
Ordinal models used in the package are Ordered Stereotype Model (OSM),
Proportional Odds Model (POM) and a dedicated Binary Model for binary data.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">clustord</span><span class="op">(</span></span>
<span>  <span class="va">formula</span>,</span>
<span>  <span class="va">model</span>,</span>
<span>  nclus.row <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  nclus.column <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  <span class="va">long.df</span>,</span>
<span>  initvect <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  pi.init <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  kappa.init <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  EM.control <span class="op">=</span> <span class="fu">default.EM.control</span><span class="op">(</span><span class="op">)</span>,</span>
<span>  optim.method <span class="op">=</span> <span class="st">"L-BFGS-B"</span>,</span>
<span>  optim.control <span class="op">=</span> <span class="fu">default.optim.control</span><span class="op">(</span><span class="op">)</span>,</span>
<span>  constraint_sum_zero <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  start_from_simple_model <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  parallel_starts <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  nstarts <span class="op">=</span> <span class="fl">5</span>,</span>
<span>  verbose <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-formula">formula<a class="anchor" aria-label="anchor" href="#arg-formula"></a></dt>
<dd><p>model formula (see 'Details').</p></dd>


<dt id="arg-model">model<a class="anchor" aria-label="anchor" href="#arg-model"></a></dt>
<dd><p><code>"OSM"</code> for Ordered Stereotype Model or <code>"POM"</code> for
Proportional Odds Model or <code>"Binary"</code> for binary data model.</p></dd>


<dt id="arg-nclus-row">nclus.row<a class="anchor" aria-label="anchor" href="#arg-nclus-row"></a></dt>
<dd><p>number of row clustering groups.</p></dd>


<dt id="arg-nclus-column">nclus.column<a class="anchor" aria-label="anchor" href="#arg-nclus-column"></a></dt>
<dd><p>number of column clustering groups.</p></dd>


<dt id="arg-long-df">long.df<a class="anchor" aria-label="anchor" href="#arg-long-df"></a></dt>
<dd><p>data frame with at least three columns, <code>Y</code> and <code>ROW</code>
and <code>COL</code>. Each row in the data frame corresponds to a single cell
in the original data matrix; the response value in that cell is given by
<code>Y</code>, and the row and column indices of that cell in the matrix are
given by <code>ROW</code> and <code>COL</code>. Use <code><a href="mat2df.html">mat2df</a></code> to create
this data frame from your data matrix of responses.
<code><a href="mat2df.html">mat2df</a></code> also allows you to supply data frames of row or
column covariates which will be incorporated into <code>long.df</code>.</p></dd>


<dt id="arg-initvect">initvect<a class="anchor" aria-label="anchor" href="#arg-initvect"></a></dt>
<dd><p>(default NULL) vector of starting parameter values for the model.
    Note: if the user enters an initial vector of parameter values, it is
    <strong>strongly recommend</strong> that the user also check the values of
    <code>parlist.init</code> in the output object, to <strong>make sure that the
    constructed parameters are as expected</strong>.</p>
<p>If <code>NULL</code>, starting parameter values will be generated automatically.</p>
<p>See 'Details' for definitions of the parameters used for different models.</p></dd>


<dt id="arg-pi-init">pi.init<a class="anchor" aria-label="anchor" href="#arg-pi-init"></a></dt>
<dd><p>(default <code>NULL</code>) starting parameter values for the proportions
    of observations in the different row clusters.</p>
<p>If <code>NULL</code>, starting values will be generated automatically.</p>
<p>User-specified values of <code>pi.init</code> must be of length <code>(nclus.row-1)</code>
    because the final value will be automatically calculated so that the
    values of <code>pi</code> sum to 1.</p></dd>


<dt id="arg-kappa-init">kappa.init<a class="anchor" aria-label="anchor" href="#arg-kappa-init"></a></dt>
<dd><p>(default <code>NULL</code>) starting parameter values for the
    proportions of observations in the different column clusters.</p>
<p>If <code>NULL</code>, starting values will be generated automatically.</p>
<p>User-specified values of <code>kappa.init</code> must be of length
    <code>(nclus.column-1)</code> because the final value will be automatically
    calculated so that the values of <code>kappa</code> sum to 1.</p></dd>


<dt id="arg-em-control">EM.control<a class="anchor" aria-label="anchor" href="#arg-em-control"></a></dt>
<dd><p>(default = <code>list(EMcycles=50, EMlikelihoodtol=1e-4,
    EMparamtol=1e-2, paramstopping=TRUE, startEMcycles=10, keepallparams=FALSE,
    epsilon=1e-6)</code>)
    list of parameters controlling the EM algorithm.</p>
<p><code>EMcycles</code> controls how many EM iterations of the main EM algorithm
    are used to fit the chosen submodel.</p>
<p><code>EMlikelihoodtol</code> is the tolerance for the stopping criterion for
    the <strong>log-likelihood</strong> in the EM algorithm. The criterion is the
    absolute change in the <strong>incomplete</strong> log-likelihood since the
    previous iteration, scaled by the size of the dataset <code>n*p</code>, where
    <code>n</code> is the number of rows in the data matrix and <code>p</code> is the
    number of columns in the data matrix. The scaling is applied because the
    incomplete log-likelihood is predominantly affected by the dataset size.</p>
<p><code>EMparamtol</code> is the tolerance for the stopping criterion for the
    <strong>parameters</strong> in the EM algorithm. This is a tolerance for the
    <strong>sum</strong> of the scaled parameter changes from the last iteration,
    i.e. the tolerance is not for any individual parameter but for the sum of
    changes in all the parameters. Thus the default tolerance is 1e-2.
    The individual parameter criteria are the absolute differences between
    the exponentiated absolute parameter value at the current timestep and
    the exponentiated absolute parameter value at the previous timestep, as a
    proportion of the exponentiated absolute parameter value at the current
    timestep. The exponentiation is to rescale parameter values that are
    close to zero.</p>
<p>there are around 5 independent parameter values, then at the point of
    convergence using default tolerances for the log-likelihood and the
    parameters, each parameter will have a scaled absolute change since the
    previous iteration of about 1e-4; if there are 20 or 30 independent
    parameters, then each will have a scaled aboslute change of about 1e-6.</p>
<p><code>paramstopping</code>: if <code>FALSE</code>, indicates that the EM algorithm
    should only check convergence based on the change in incomplete-data
    log-likelihood, relative to the current difference between the
    complete-data and incomplete-data log-likelihoods, i.e.
    <code>abs(delta_lli)/abs(llc[iter] - lli[iter])</code>;
    if <code>TRUE</code>, indicates that as well as checking the likelihood
    criterion, the EM algorithm should also check whether the relative change
    in the exponentials of the absolute values of the current parameters is
    below the tolerance <code>EMstoppingpar</code>, to see whether the parameters
    and the likelihood have both converged.</p>
<p><code>startEMcycles</code> controls how many EM iterations are used when
    fitting the simpler submodels to get starting values for fitting models
    with interaction.</p>
<p><code>keepallparams</code>: if <code>TRUE</code>, keep a record of parameter values
    (including pi_r and kappa_c) for every EM iteration.</p>
<p><code>rerunestepbeforelli</code>: if <code>TRUE</code>, and only when using biclustering,
    rerun the E-step before calculating the incomplete-data log-likelihood.
    The EM algorithm runs the E-step to estimate the cluster membership
    probabilities and then runs the M-step to estimate the parameters by
    maximising the complete-data log-likelihood (LLC), and then recalculates
    the estimated incomplete-data log-likelihood (LLI) to check for
    convergence. The biclustering LLI approximation uses the cluster
    membership probabilities so will be slightly more accurate if these
    cluster membership probabilities are recalculated using the very latest
    parameter estimates. So the <code>TRUE</code> setting for this control
    recalculates the cluster memberships before calculating the LLI approx.</p>
<p><code>uselatestlli</code>: Kept for backwards compatibility with original
    version of clustord algorithm. Original version of the algorithm had this
    set to <code>FALSE</code>, which keeps the best LLI from any previous iteration
    rather than the latest LLI. The default, <code>TRUE</code>, instead keeps the
    latest LLI even if there was a better LLI in a previous iteration. This
    is appropriat: In row clustering the exact LLI is used and the EM
    algorithm creators proved the LLI should always not decrease with each
    iteration. In biclustering the approximation to the LLI may be very
    inaccurate when the algorithm is a long way from convergence, so even
    when the value of LLI appears to be very high in early iterations this
    may not be accurate, so it is better to take the latest value.</p>
<p>For <code>columnclustering</code>, the parameters saved from each iteration
    will NOT be converted to column clustering format, and will be in the row
    clustering format, so <code>alpha</code> in
    <code>EM.status$params.every.iteration</code> will correspond to beta_c and
    <code>pi</code> will correspond to kappa.</p>
<p><code>epsilon</code>: default 1e-6, small value used to adjust values of pi,
    kappa and theta that are too close to zero so that taking logs of them
    does not create infinite values.</p></dd>


<dt id="arg-optim-method">optim.method<a class="anchor" aria-label="anchor" href="#arg-optim-method"></a></dt>
<dd><p>(default "L-BFGS-B") method to use in optim within the M
step of the EM algorithm. Must be one of 'L-BFGS-B', 'BFGS', 'CG' or
'Nelder-Mead' (i.e. not the SANN method).</p></dd>


<dt id="arg-optim-control">optim.control<a class="anchor" aria-label="anchor" href="#arg-optim-control"></a></dt>
<dd><p>control list for the <code>optim</code> call within the M step
of the EM algorithm. See the control list Details in the <code>optim</code>
manual for more info.
Please note that although <code>optim</code>, by default, uses <code>pgtol=0</code>
and <code>factr=1e7</code> in the L-BFGS-B method, <code>clustord</code>, by default,
alters these to <code>pgtol=1e-4</code> and <code>factr=1e11</code>, but you can use
this <code>optim.control</code> argument in <code>clustord</code> to revert them to
the defaults if you want. The reason for the change is that the chosen
values in <code>clustord</code> reduce the tolerance on the log-likelihood
function optimization in order to speed up the algorithm, and because the
log-likelihood is on the scale of 1e4 for &lt;100 rows in the data matrix
and 1e6 for 5000 rows in the data matrix, tolerance at the default
<code>optim</code> scale is not as important as the choice of model type and
structure or the number of starting points. If one model is better than
another, it will probably have a likelihood that is better by about the
size of the data matrix, which is far larger than the tolerance in the
optimization. If one starting point is better than another, it will
probably have a likelihood that is better on about 1/10th or 1/100th the
size of the data matrix, which is still far larger than the tolerance in
the optimization.
If you need accurate parameter estimates, firstly make sure to try more
starting points, then perform model selection first, and then finally
rerun the chosen model with finer tolerance, e.g. the <code>optim</code>
defaults, <code>pgtol=0</code> and <code>factr=1e7</code>.</p></dd>


<dt id="arg-constraint-sum-zero">constraint_sum_zero<a class="anchor" aria-label="anchor" href="#arg-constraint-sum-zero"></a></dt>
<dd><p>(default <code>TRUE</code>) if <code>TRUE</code>, use constraints
that cluster effects sum to zero; if <code>FALSE</code>, use constraints that
the cluster effect for the first cluster will be 0.
Both versions have the same constraints for joint row-column cluster
effects: these effects are described by a matrix of parameters gamma_rc,
indexed by row cluster and column cluster indices, and the constraints
are that the final column of gamma_rc is equal to the negative sum of the
other columns (so <code>gamma</code> columns sum to zero) and first row of
gamma_rc is equal to the negative sum of the other rows (so <code>gamma</code>
rows sum to zero).</p></dd>


<dt id="arg-start-from-simple-model">start_from_simple_model<a class="anchor" aria-label="anchor" href="#arg-start-from-simple-model"></a></dt>
<dd><p>(default <code>TRUE</code>) if <code>TRUE</code>, fit a
simpler clustering model first and use that to provide starting values for
all parameters for the model with interactions;
if <code>FALSE</code>, use the more basic models to provide starting values only
for <code>pi.init</code> and <code>kappa.init</code>.
If the full model has interaction terms, then simpler models are ones
without the interactions. If the model has individual row/column effects
alongside the clusters, then simpler models are ones without the individual
row/column effects. If the full model has covariates, then simpler models
are ones without the covariates (to get starting values for the cluster
parameters), and ones with the covariates but no clustering (to get
starting values for the covariates).</p></dd>


<dt id="arg-parallel-starts">parallel_starts<a class="anchor" aria-label="anchor" href="#arg-parallel-starts"></a></dt>
<dd><p>(default FALSE) if TRUE, by generating multiple random
starts, those random starts will be parallelised over as many cores as are
available. For example, on a personal computer this will be one fewer than
the number of cores in the machine, to make sure one is left for system
tasks external to R.</p></dd>


<dt id="arg-nstarts">nstarts<a class="anchor" aria-label="anchor" href="#arg-nstarts"></a></dt>
<dd><p>(default 5) number of random starts to generate, if generating
random starting points for the EM algorithm.</p></dd>


<dt id="arg-verbose">verbose<a class="anchor" aria-label="anchor" href="#arg-verbose"></a></dt>
<dd><p>(default <code>FALSE</code>) changes how much is reported to the
console during the algorithm's progress. If <code>TRUE</code>, reports the
incomplete-data log-likelihood at every EM algorithm iteration and the
trace information from nnet::multinom() during the process of fitting
initial values for the <code>mu</code> parameters. If <code>FALSE</code>, the
incomplete log-likelihood is only reported every 10 iterations of the EM
algorithm and the initial fitting reporting is suppressed. Regardless of
the verbosity setting the algorithm reports each of the random starts and
whenever it finds a better log-likelihood than all previous starts, and it
also reports when it is fitting simpler models to find starting values for
the parameters vs fitting the final, more complex model.
If wanting the detailed output from <code><a href="https://rdrr.io/r/stats/optim.html" class="external-link">optim()</a></code>, use
<code>optim.control=list(trace=X)</code>, where X is 1 to 6, with 6 being the
highest level of verbosity for the L-BFGS-B algorithm.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>A <code>clustord</code> object, i.e. a list with components:</p>
<p><code>info</code>: Basic info n, p, q, the number of parameters, the number of
    row clusters and the number of column clusters, where relevant.</p>
<p><code>model</code>: The model used for fitting, "OSM" for Ordered Stereotype
    Model, "POM" for Proportional Odds Model, or "Binary" for Binary model.</p>
<p><code>EM.status</code>: a list containing the latest iteration <code>iter</code>,
    latest incomplete-data and complete-data log-likelihoods <code>new.lli</code>
    and <code>new.llc</code>, the best incomplete-data log-likelihood <code>best.lli</code>
    and the corresponding complete-data log-likelihood, <code>llc.for.best.lli</code>,
    and the parameters for the best incomplete-data log-likelihood,
    <code>params.for.best.lli</code>, indicator of whether the algorithm converged
    <code>converged</code>, and if the user chose to keep all parameter values from
    every iteration, also <code>params.every.iteration</code>.</p>
<p>Note that for <strong>biclustering</strong>, i.e. when <code>ROWCLUST</code> and
    <code>COLCLUST</code> are both included in the model, the <strong>incomplete</strong>
    log-likelihood is calculated using the entropy approximation, and this
    may be <strong>inaccurate</strong> unless the algorithm has converged or is close
    to converging. So beware of using the incomplete log-likelihood and the
    corresponding AIC value <strong>unless the EM algorithm has converged</strong>.</p>
<p><code>criteria</code>: the calculated values of AIC, BIC,
    etc. from the best incomplete-data log-likelihood.</p>
<p><code>epsilon</code>: the very small value (default 1e-6) used to adjust values
    of pi and kappa and theta that are too close to zero, so that taking logs
    of them does not produce infinite values. Use the EM.control argument to
    adjust epsilon.</p>
<p><code>constraints_sum_zero</code>: the chosen value of constraints_sum_zero.</p>
<p><code>param_lengths</code>: vector of total number of parameters/coefficients
    for each part of the model, labelled with the names of the components.
    The value is 0 for each component that is not included in the model, e.g.
    if there are no covariates interacting with row clusters then the
    <code>rowc_cov_coef</code> value will be 0. If the component is included, then
    the value given will include any dependent parameter/coefficient values,
    so if column clusters are included then the <code>colc_coef</code> value will
    be <code>nclus.column</code>, whereas the number of independent values will be
    <code>nclus.column - 1</code>.</p>
<p><code>initvect</code>: the initial <em>vector</em> of parameter values, either
    specified by the user or generated automatically. This vector has only
    the <strong>independent</strong> values of the parameters, not the full set.</p>
<p><code>outvect</code>: the final <em>vector</em> of parameter values, containing
    only the independent parameter values from <code>parlist.out</code>.</p>
<p><code>parlist.init</code>: the initial list of parameters, constructed from
    the initial parameter vector <code>initvect</code>. Note that if the initial
    vector has been incorrectly specified, the values of <code>parlist.init</code>
    may not be as expected, and they should be checked by the user.</p>
<p><code>parlist.out</code>: fitted values of parameters.</p>
<p><code>pi</code>, <code>kappa</code>: fitted values of pi and kappa, where relevant.</p>
<p><code>ppr</code>, <code>ppc</code>: the posterior probabilities of membership of the
    row clusters and the column clusters, where relevant.</p>
<p><code>rowc_mm</code>, <code>colc_mm</code>, <code>cov_mm</code>: the model matrices for,
    respectively, the covariates interacting with row clusters, the covariates
    interacting with column clusters, and the covariates not interacting with
    row or column clusters (i.e. the covariates with constant coefficients).
    Note that one row of each model matrix corresponds to one row of long.df.</p>
<p><code>RowClusters</code>, <code>ColumnClusters</code>: the assigned row and column
    clusters, where relevant, where each row/column is assigned to a cluster
    based on maximum posterior probability of cluster membership (<code>ppr</code>
    and <code>ppc</code>).</p>
<p><code>RowClusterMembers</code>, <code>ColumnClusterMembers</code>: vectors of
    assigned members of each row or column cluster, where each row/column is
    assigned to a cluster based on maximum posterior probability of cluster
    membership (<code>ppr</code> and <code>ppc</code>)</p>
    </div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>You can select your own input parameters, or starting values will be
generated by running kmeans or by fitting simpler models and feeding the
outputs into the final model as starting values.</p>
<p>The starting point for clustering is a data matrix of response values that
are binary or categorical. You may also have a data frame of covariates that
are linked to the rows of the data matrix, and may also have a data frame of
covariates that are linked to the columns of the data matrix.</p>
<p>For example, if clustering data from fishing trawls, where the rows are trawl
events and columns are species caught, then you could also supply a gear
covariate linked to the rows, representing gear used on each trawl event, and
could additionally supply species covariates linked to the columns,
representing auxiliary information about each species. There is no
requirement to provide any covariates, and you can provide only row
covariates, or only column covariates.</p>
<p>Before running <code>clustord</code>, you need to run <code><a href="mat2df.html">mat2df</a></code> to
convert the data matrix into a long form data frame. The data frame needs to
have at least three columns, <code>Y</code> and <code>ROW</code> and <code>COL</code>. Each row
in the data frame corresponds to a single cell in the original data matrix;
the response value in that cell is given by <code>Y</code>, and the row and column
indices of that cell in the matrix are given by <code>ROW</code> and <code>COL</code>.</p>
<p><code><a href="mat2df.html">mat2df</a></code> also allows you to supply data frames of row or column
covariates which will be incorporated into <code>long.df</code>.</p>
<p>Then, to run the <code>clustord</code> function, you need to enter your chosen
formula and model, and the number of clusters you want to fit. The formula
model_structure is akin to that for <code>glm</code>, but with a few restrictions. You
can include any number of covariates in the same way as for a multiple
regression model, though unlike for <code>glm</code>, you can include both row and
column covariates.</p>
<p>Note that, unlike <code>glm</code>, you should not specify a <code>family</code>
argument; the <code>model</code> argument is used instead.</p>
<p><code>formula</code> <strong>argument details</strong></p>
<p>In the following description of different models, the Binary model is used
for simplicity when giving the mathematical descriptions of the models, but
you can use any of the following models with the Ordered Stereotype or
Proportional Odds Models as well.</p>
<p>In the <code>formula</code> argument, the response must be exactly <code>Y</code>. You
cannot use any functions of <code>Y</code> as the response, nor can you include
<code>Y</code> in any terms on the right hand side of the formula. <code>Y</code> is the
name in <code>clustord</code> of the response values in the original data matrix.</p>
<p>The <code>formula</code> argument has 4 special variables: <code>ROWCLUST</code>,
<code>COLCLUST</code>, <code>ROW</code> and <code>COL</code>. There are some restrictions on
how these can be used in the formula, as they are not covariates, but instead
act as indicators of the clustering model_structure you want to use.</p>
<p>All other variables in the formula will be any covariates that you want to
include in the model, and these are unrestricted, and can be used in the same
way as in <code>glm</code>.</p>
<p><code>ROWCLUST</code> and <code>COLCLUST</code> are used to indicate what row clustering
model_structure you want, and what column clustering model_structure you want,
respectively. The inclusion of <code>ROWCLUST</code> as a single term indicates
that you want to include a row clustering effect in the model. In the
simplest row clustering model, for Binary data with <strong>row clustering</strong>
effects only, the basic function call would be</p>
<p><code>clustord(Y ~ ROWCLUST, model="Binary", long.df=long.df)</code></p>
<p>and the model fitted would have the form:</p>
<p>Logit(P(Y = 1)) = mu + rowc_coef_r</p>
<p>where mu is the intercept term, and rowc_coef_r is the row cluster effect
that will be applied to every row from the original data matrix that is a
member of row cluster r. The inclusion of <code>ROWCLUST</code> corresponds to the
inclusion of rowc_coef_r.</p>
<p>Note that we are not using notation involving greek letters, because (a) we
ran out of letters for all the different types of parameters in the model and
(b) with this many parameters, it would be difficult to remember which ones
are which.</p>
<p>Similarly to row clustering, the formula <code>Y ~ COLCLUST</code> would perform
<strong>column clustering</strong>, with model Logit(P(Y = 1)) = mu + colc_coef_c,
where colc_coef_c is the column cluster effect that will be applied to every
column from the original data matrix that is a member of column cluster c.</p>
<p>Including both <code>ROWCLUST</code> and <code>COLCLUST</code> in the same formula
indicates that you want to perform biclustering, i.e. you want to cluster the
rows and the columns of the original data matrix simultaneously. If included
without interaction, then the terms just correspond to including rowc_coef_r
and colc_coef_c in the model:</p>
<p>The formula</p>
<p><code>Y ~ ROWCLUST + COLCLUST</code></p>
<p>is the simplest possible <strong>biclustering</strong> model,
Logit(P(Y = 1)) = mu + rowc_coef_r + colc_coef_c</p>
<p>If you want to include interaction between the rows and columns, i.e. you
want to perform block biclustering where each block corresponds to a row
cluster r and a column cluster c, then that model has a matrix of parameters
indexed by r and c.</p>
<p><code>clustord(Y ~ ROWCLUST*COLCLUST, model="Binary", ...)</code> has the model
Logit(P(Y = 1)) = mu + rowc_colc_coef_rc</p>
<p>This model can instead be called using the equivalent formula
<code>Y ~ ROWCLUST + COLCLUST + ROWCLUST:COLCLUST</code>.</p>
<p>You can instead use the formula <code>Y ~ ROWCLUST:COLCLUST</code>. Mathematically,
this is equivalent to the previous two. In regression, the models would not
be equivalent but in clustering, they are equivalent, and have the same
number of independent parameters overall. If you include the main effects,
then that reduces the number of independent parameters in the interaction
term compared to if you just use the interaction term (see below section about
<code>initvect</code>).</p>
<p>You cannot include just one of the main effects alongside the interaction
term, i.e. you cannot use <code>Y ~ ROWCLUST + ROWCLUST:COLCLUST</code> or
<code>Y ~ COLCLUST + ROWCLUST:COLCLUST</code>. This is for simplicity in the code,
and to avoid confusion when interpreting the results.</p>
<p>However, <code>clustord</code> allows a lot more flexibility than this. The
variables <code>ROW</code> and <code>COL</code> are used to indicate that you want to
also include <strong>individual row or column effects</strong>, respectively.</p>
<p>For example, if you are clustering binary data that indicates the presence/
absence of different species (columns) at different trawl events (rows), and
you know that one particular species is incredibly common, then you can
include column effects in the model, which will allow for the possibility
that two columns may correspond to species with different probabilities of
appearing in the trawl.</p>
<p>You can add individual column effects along with
row clustering, or you can add individual row effects along with column clustering.
The formula for row clustering with individual column effects (without
interaction) is</p>
<p><code>Y ~ ROWCLUST + COL</code></p>
<p>which corresponds to Binary model</p>
<p>Logit(P(Y = 1)) = mu + rowc_coef_r + col_coef_j</p>
<p>So if two cells from the data matrix are in the same row cluster, but in
different columns, they will not have the same probability of Y = 1.</p>
<p>You can also add interaction between the individual row/column effects and
the clustering effects.</p>
<p>If you still want to be able to see the row cluster and column effects
separately, then you use <code>Y ~ ROWCLUST*COL</code> or
<code>Y ~ ROWCLUST + COL + ROWCLUST:COL</code> (these are both the same), which
have model</p>
<p>Logit(P(Y = 1)) = mu + rowc_coef_r + col_coef_j + rowc_col_coef_rj</p>
<p>As before, rowc_coef_r and col_coef_j are the row cluster effects and
individual column effects, and rowc_col_coef_rj are the interaction terms.</p>
<p>Alternatively, you can use the mathematically-equivalent formula</p>
<p><code>Y ~ ROWCLUST:COL</code> which has model</p>
<p>Logit(P(Y = 1)) = mu + rowc_col_coef_rj</p>
<p>where the row cluster effects and individual column effects are absorbed into
the matrix rowc_col_coef_rj. These models are the same mathematically, the
only differences between them are in how they are constrained (see below in
the section about the <code>initvect</code> argument) and how they should be
interpreted.</p>
<p>Note that if you were using covariates, then it would not be equivalent to
leave out the main effects and just use the interaction terms, but the
clustering models don't work quite the same as regression models with
covariates.</p>
<p>Equivalently, if you want to cluster the columns, you can include individual
row effects alongside the column clusters, i.e.</p>
<p><code>Y ~ COLCLUST + ROW</code> or <code>Y ~ COLCLUST + ROW + COLCLUST:ROW</code>,</p>
<p>depending on whether you want the interaction terms or not.</p>
<p>You are <strong>not</strong> able to include individual row effects with row clusters,
or include individual column effects with column clusters, because there is
not enough information in ordinal or binary data to fit these models. As a
consequence, you cannot include individual row or column effects if you are
doing biclustering, e.g.</p>
<p><code>Y ~ ROWCLUST + COLCLUST + ROW</code> or <code>Y ~ ROwCLUST + COLCLUST + COL</code></p>
<p>are not permitted.</p>
<p>From version 1 of the package, you can now also include <strong>covariates</strong>
alongside the clustering patterns. The basic way to do this is include them
as additions to the clustering model_structure. For example, including one row
covariate <code>xr</code> to a row clustering model would have the formula</p>
<p><code>Y ~ ROWCLUST + xr</code></p>
<p>with Binary model Logit(P(Y = 1)) = mu + rowc_coef_r + row_coef_1*xr_i</p>
<p>where row_coef_1 is the coefficient of xr_i, just as in a typical regression
model.</p>
<p>Additional row covariates can also be included, and you can include
interactions between them, and functions of them, as in regression models, e.g.</p>
<p><code>Y ~ ROWCLUST + xr1*log(xr2)</code></p>
<p>which would have the Binary model</p>
<p>Logit(P(Y = 1)) = mu + rowc_coef_r + row_coef1*xr1_i + row_coef2*log(xr2_i) +
                         row_coef3*xr1_i*log(xr2_i)</p>
<p>If instead you want to add column covariates to the model, they work in the
same way after they've been added to the <code>long.df</code> data frame using
<code><a href="mat2df.html">mat2df</a></code>, but they are indexed by j instead of i. Simplest model,
with one single column covariate xc, would have formula</p>
<p><code>Y ~ ROWCLUST + xc</code></p>
<p>with Binary model Logit(P(Y = 1)) = mu + rowc_coef_r + col_coef1*xc_j</p>
<p>You can use any functions of or interactions between column covariates, just
as with row covariates. You can similarly add row or column covariates to
column clustering or biclustering models.</p>
<p>You can include <strong>interactions between covariates</strong> and <code>ROWCLUST</code>
or <code>COLCLUST</code> in the formula. But these are <strong>not quite</strong> the same
as interactions between covariates. The formula</p>
<p><code>Y ~ ROWCLUST*xr</code></p>
<p>where <code>xr</code> is some row covariate, corresponds to the Binary model</p>
<p>Logit(P(Y = 1)) = mu + rowc_coef_r + cov_coef*xr_i + rowc_row_coef_r1*xr_i</p>
<p>What this means is that there is a term in the linear predictor that involves
the row covariate xr (which has the index i because it is a row covariate),
and each cluster (indexed by r) has a different coefficient for
that covariate (as distinct from the non-interaction covariate models above,
which have the same coefficients for the covariates regardless of which
cluster the row is in).</p>
<p>This is different from interaction terms involving only covariates, where two
or more covariates appear multiplied together in the model and then have a
shared coefficient term attached to them. In a clustering/covariate
interaction, the row or column clustering pattern controls the coefficients
rather than adding a different type of covariate.</p>
<p>Note that the pure cluster effect rowc_coef_r is also included in the model
automatically, in the same way that a regression formula <code>Y ~ x1*x2</code>
would include the individual x1 and x2 effects as well as the interaction
between x1 and x2.</p>
<p>The coefficients for row clusters interacting with row coefficients are named
<code>row_cluster_row_coef</code> in the output of <code>clustord</code> because you
can also have coefficients for interactions between row clustering and column
covariates, or column clustering and row covariates, or column clustering and
column covariates. Row clustering interacting with column covariates would
look something like</p>
<p><code>Y ~ ROWCLUST*xc</code></p>
<p>with Binary model Logit(P(Y = 1)) = mu + rowc_coef_r + rowc_col_coef_r1*xc_j</p>
<p>The other combinations of clustering and covariates work similarly.
<code>rowc_col_coef_rl</code> and the other similar coefficients have two indices.
Their first index is the index of the cluster, and their second index is the
index of the covariate among the list of covariates interacting with that
direction of clustering. So if there are two row covariates <code>xr1</code> and
<code>xr2</code> interacting with three row clusters, that gives you 6
coefficients:</p>
<p><code>rowc_col_coef_11, rowc_col_coef_12,
rowc_col_coef_21, rowc_col_coef_22,
rowc_col_coef_31, rowc_col_coef_32</code>.</p>
<p>and you can also have a three-way interaction between row cluster and those
two covariates, which would add the coefficients <code>rowc_col_coef_r3</code>
for the <code>xr1:xr2</code> term.</p>
<p>You can instead add covariates that interact with column clusters, which will
have parameters <code>colc_row_coef_cm</code>, where <code>m</code> here indexes just the
covariates interacting with column cluster.</p>
<p>If you have covariates interacting with row clusters and other covariates
interacting with column clusters, then you will have parameters
<code>rowc_cov_coef_rl</code> <strong>and</strong> <code>colc_cov_coef_cm</code>.</p>
<p>An example of this is the model</p>
<p><code>Y ~ ROWCLUST + xr1 + ROWCLUST:xr1 + xc1 + COLCLUST + COLCLUST:log(xc1)</code></p>
<p>This has main effects for row clusters and column clusters, i.e.
<code>ROWCLUST</code> and <code>COLCLUST</code>. It also has two covariate terms not
interacting with clusters, <code>xr1</code> and <code>xc1</code>. It also has 1 covariate
term interacting with row clusters, <code>xr1</code>, with coefficients
<code>rowc_cov_coef_r1</code>, and 1 covariate term interacting with column
clusters, <code>log(xc1)</code>, with coefficients <code>colc_cov_coef_c1</code>.</p>
<p><strong>Restrictions on <code>formula</code></strong></p>
<p>The primary restriction on the <code>formula</code> argument is that that you
<strong>cannot</strong> use functions of <code>ROW</code>, <code>COL</code>, <code>ROWCLUST</code> or
<code>COLCLUST</code>, such as <code>log(ROW)</code> or I(COLCLUST^2). That is because
they are not covariates, and cannot be manipulated like that; instead, they
are indicators for particular elements of the clustering model_structure.</p>
<p>If performing biclustering, i.e. if <code>ROWCLUST</code> and <code>COLCLUST</code> are
both in the model, and you want to include the interaction between them, then
you can use the interaction between them on its own, or you can include both
main effects, but you are not allowed to use just one main effect alongside
the interaction. That is, you can use</p>
<p><code>Y ~ ROWCLUST + COLCLUST + ROWCLUST:COLCLUST</code> or <code>Y ~ ROWCLUST*COLCLUST</code>,</p>
<p>or you can use <code>Y ~ ROWCLUST:COLCLUST</code>, and these two types of
biclustering model will have different parameter constraints (see below under
<code>initvect</code> details), but you <strong>cannot</strong> use</p>
<p><code>Y ~ ROWCLUST + ROWCLUST:COLCLUST</code> or <code>Y ~ COLCLUST + ROWCLUST:COLCLUST</code></p>
<p>As stated above, you also cannot include individual row effects alongside
row clustering, and you cannot use individual column effects alongside
column clustering, i.e. if <code>ROWCLUST</code> is in the formula, then <code>ROW</code>
<strong>cannnot</strong> be in the formula, and if <code>COLCLUST</code> is in the formula
then <code>COL</code> <strong>cannot</strong> be in the formula.</p>
<p>If you are including <code>COL</code> with <code>ROWCLUST</code>, then you can include
the interaction between them but that is the <strong>only</strong> permitted interaction
term that involves <code>COL</code>, and similarly the interaction between
<code>ROW</code> and <code>COLCLUST</code> is the <strong>only</strong> permitted interaction
term that involves <code>ROW</code>. But you can include those interactions in the
form</p>
<p><code>Y ~ ROWCLUST + COL + ROWCLUST:COL</code> or as <code>Y ~ ROWCLUST*COL</code>, or as
<code>Y ~ ROWCLUST:COL</code>.</p>
<p>These are the only permitted uses of the <code>COL</code> term, and there are
equivalent constraints on the inclusion of <code>ROW</code>.</p>
<p>As stated above, you can include interactions between <code>ROWCLUST</code> or
<code>COLCLUST</code> and covariates, but you <strong>cannot</strong> include three-way
interactions between <code>ROWCLUST</code>, <code>COLCLUST</code> and one or more
covariates are <strong>not permitted</strong> in <code>clustord</code>, mostly because
of the prohibitive number of parameter values that would need to be fitted,
and the difficulty of interpreting such a model. That is, you cannot use
formulae such as <code>Y ~ ROWCLUST*COLCLUST*xr</code>, which would have Binary
model Logit(P(Y = 1)) = mu + bi_cluster_row_coef_rc1*xr_i.</p>
<p><code>model</code> <strong>argument details</strong></p>
<p>The three models available in <code>clustord</code> are the Binary model, which
is a Bernoulli model equivalent to the binary model in the package
<code>clustglm</code>, the Proportional Odds Model (POM) and the Ordered Stereotype
Model (OSM).</p>
<p>Many Binary model examples have been given above, which have the general
form</p>
<p>logit(P(Y = 1)) = mu + &lt;&lt;linear terms&gt;&gt;</p>
<p>where the linear terms can include row or column clustering effects,
individual row or column effects, and row or column covariates, with or
without interactions with row or column clustering.</p>
<p>The Proportional Odds Model and the Ordered Stereotype Model have the same
model_structure for the linear terms, but the overall model equation is different.</p>
<p>The Proportional Odds Model (<code>model = "POM"</code>) has the form</p>
<p>logit(P(Y &lt;= k)) = log(P(Y &lt;= k)/P(Y &gt; k)) = mu_k - &lt;&lt;linear terms&gt;&gt;</p>
<p>So the simplest POM for row clustering would be</p>
<p>logit(P(Y &lt;= k)) = mu_k - rowc_coef_r</p>
<p>and the model including individual column effects and no interactions would be</p>
<p>logit(P(Y &lt;= k)) = mu_k - rowc_coef_r - col_coef_j</p>
<p>Note that the linear-term coefficients have negative signs for the
Proportional Odds Models. This is so that as the row cluster index increases,
or as the column index increases, Y is more likely to fall at higher values
(see Ch4 of Agresti, 2010).</p>
<p>The Ordered Stereotype model (<code>model = "OSM"</code>) has the form</p>
<p>log(P(Y = k)/P(Y = 1)) = mu_k + phi_k(&lt;&lt;linear terms&gt;&gt;)</p>
<p>So the simplest OSM for row clustering would be</p>
<p>log(P(Y = k)/P(Y = 1)) = mu_k + phi_k*rowc_coef_r</p>
<p>and the model including individual column effects and no interactions would be</p>
<p>log(P(Y = k)/P(Y = 1)) = mu_k + phi_k(rowc_coef_r + col_coef_j)</p>
<p>Note that the OSM is <strong>not</strong> a cumulative logit model, unlike the POM.
The model describes the log of the kth level relative to the first level,
which is the baseline category, but the patterns for k = 2 may be different
than the patterns for k = 3. They are linked, because the linear terms will
be the same, but they may not have the same shape. In this sense, the OSM is
more flexible/less restrictive than the POM.</p>
<p>See Anderson (1984) for the original definition of the ordered stereotype
model, and see Fernández et al. (2016) for the application to clustering.</p>
<p>The phi_k parameters may be treated as "score" parameters. After fitting the
OSM, the fitted phi_k values can give some indication of what the true
separation is between the categories. Even if the default labelling of the
categories is from 1 to n, that doesn't mean that the categories are actually
equally spaced in reality. But the fitted phi_k values from the OSM can be
treated as data-derived numerical labels for the categories. Moreover, if two
categories have very similar fitted phi_k values, e.g. if phi_2 = 0.11 and
phi_3 = 0.13, that suggests that there is not enough information in the data
to distinguish between categories 2 and 3, and so you might as well merge
them into a single category to simplify the model-fitting process and the
interpretation of the results.</p>
<p><code>initvect</code> <strong>argument details</strong></p>
<p>Initvect is the vector of starting values for the parameters, made up of
sections for each different type of parameter in the model. Note that the
length of each section of initvect is the number of <strong>independent</strong>
parameter values, not the overall number of parameter values of that type.</p>
<p>If you want to supply a vector of starting values for the EM algorithm, you
need to be careful how many values you supply, and the order in which you
include them in <code>initvect</code>, and you should <strong>CHECK</strong> the output
list of parameters (which is the full set of parameter values, including
dependent ones, broken up into each type of parameter) to check that your
initvect model_structure is correct for the formula you have specified.</p>
<p>For example, the number of <code>mu</code> values will always be 1 fewer than the
number of categories in the data, and the remaining value of mu is dependent
on those q-1 values. In the OSM for data with 3 categories, the first value
of mu for category 1 will be 0, and then the other 2 values of mu for
categories 2 and 3 will be the independent values of mu. For the POM for data
with 5 categories, the first 4 values of mu will be the independent values
and then the last value of mu is infinity, because the probability of Y being
in category 5 is defined as 1 minus the sum of the probabilities for the
other 4 levels.</p>
<p><code>q</code> is the number of levels in the values of y, <code>n</code> is the number
of rows in the original data matrix, and <code>p</code> is the number of columns in
the original data matrix.</p>
<p>For Binary,
There is one independent value for <code>mu</code>, i.e. q = 2.</p>
<p>Ignore <code>phi</code>, which is not used in the Binary model.</p>
<p>For OSM,
The starting values for <code>mu_k</code> are length <code>q-1</code>, and the model
has <code>mu_1</code> = 0 always, so the initvect values for <code>mu</code> will become
<code>mu_2</code>, <code>mu_3</code>, etc. up to <code>mu_q</code>.</p>
<p>The starting values for <code>phi_k</code> are length <code>q-2</code>.</p>
<p>Note that the starting values for <code>phi</code> do not correspond directly to
<code>phi</code>, because <code>phi</code> is restricted to being increasing and between
0 and 1, so instead the starting values are treated as elements
<code>u[2:q-1]</code> of a vector <code>u</code> which can be between <code>-Inf</code> and
<code>+Inf</code>, and then</p>
<p><code>phi[2] &lt;- expit(u[2])</code> and</p>
<p><code>phi[k] &lt;- expit(u[2] + sum(exp(u[3:k])))</code> for k between 3 and q-1</p>
<p><code>(phi[1] = 0 and phi[q] = 1)</code>.</p>
<p>For POM,
The starting values for <code>mu_k</code> are length <code>q-1</code>, but the starting
values do not correspond directly to <code>mu_k</code>, because <code>mu_k</code> is
restricted to being increasing, i.e. the model has to have
    <code>mu_1</code> &lt;= <code>mu_2</code> &lt;= ... <code>mu_q</code> = <code>+Inf</code></p>
<p>So instead of using the initvect values directly for <code>mu_k</code>, the 2nd to
(q-1)th elements of initvect are used to construct <code>mu_k</code> as follows:</p>
<p><code>mu_1 &lt;- initvect[1]</code></p>
<p><code>mu_2 &lt;- initvect[1] + exp(initvect[2])</code></p>
<p><code>mu_3 &lt;- initvect[1] + exp(initvect[2]) + exp(initvect[3])</code></p>
<p>... and so on up to <code>mu_{k-1}</code>, and <code>mu_k</code> is infinity, because
    it is not used directly to construct the probability of Y = q.</p>
<p>Thus the values that are used to construct <code>mu_k</code> can be unconstrained,
which makes it easier to specify initvect and easier to optimize the parameter
values.</p>
<p>Ignore <code>phi</code>, which is not used in POM.</p>
<p>For <strong>all three models</strong>,</p>
<p>The starting values for <code>rowc_coef_r</code> are length <code>nclus.row-1</code>,
where <code>nclus.row</code> is the number of row clusters. The final row cluster
parameter is dependent on the others (see the input parameter info for
constraint_sum_zero), whereas if it were independent it would be colinear
with the <code>mu_k</code> parameters and thus not identifiable.</p>
<p>Similarly the starting values for <code>colc_coef_c</code> are length
<code>nclus.column-1</code>, where <code>nclus.column</code> is the number of column
clusters, to avoid problems of colinearity and nonidentifiability.</p>
<p>If you have biclustering with an interaction term between row clusters and
column clusters, then the number of independent values in the matrix of
interaction terms depends on whether you include the main effects of row and
column clusters separately. That is, if you use the biclustering model</p>
<p><code>Y ~ ROWCLUST + COLCLUST + ROWCLUST:COLCLUST</code>, or equivalently</p>
<p><code>Y ~ ROWCLUST*COLCLUST</code>,</p>
<p>then the main effect term <code>ROWCLUST</code> has <code>nclus.row-1</code> independent
parameters in <code>initvect</code>, and <code>COLCLUST</code> has <code>nclus.column-1</code>
independent parameters in <code>initvect</code>, and <code>ROWCLUST:COLCLUST</code> will
have <code>(nclus.row - 1)*(nclus.column - 1)</code> independent parameter values.
The final matrix of interaction terms will be constrained to have its last
row equal to the negative sum of the other rows, and the last column equal to
the negative sum of the other columns.</p>
<p>On the other hand, if you want to use only the interaction term and not the
main effects (which for the clustering model is mathematically equivalent),
i.e.</p>
<p><code>Y ~ ROWCLUST:COLCLUST</code>,</p>
<p>then that matrix of interaction terms will have <code>nclus.row*nclus.column - 1</code>
independent parameters, i.e. more independent parameters than if you included
the main effects.</p>
<p>If you have column effects alongside row clusters (they are not permitted
alongside column clusters), without interactions, i.e. the formula
<code>Y ~ ROWCLUST + COL</code> with Binary model Logit(P(Y = 1)) = mu +
rowc_coef_r + col_coef_j
then the row cluster coefficients have <code>nclus.row - 1</code> independent
parameters, and the column effect coefficients have <code>p - 1</code> independent
parameters, where p is the number of columns in the original data matrix,
i.e. the maximum value of <code>long.df$COL</code>.</p>
<p>If you include the interaction term, then the number of independent parameters
again depends on whether you just use the interaction term, or include the
main effects.</p>
<p>In the formula <code>Y ~ ROWCLUST + COL + ROWCLUST:COL</code> or its equivalent with
"*", the interaction term will have <code>(nclus.row - 1)*(p-1)</code> independent
parameters.</p>
<p>If you instead use the formula <code>Y ~ ROWCLUST:COL</code>, then the interaction
term will have <code>nclus.row*p - 1</code> independent parameters. Either way, the
total number of independent parameters in the model will be <code>nclus.row*p</code>.</p>
<p>Similarly, if you have row effects alongside column clusters, without
interactions, i.e. the formula</p>
<p><code>Y ~ COLCLUST + ROW</code>,</p>
<p>with Binary model Logit(P(Y = 1)) = mu + colc_coef_c + row_coef_i</p>
<p>then the column cluster coefficients will have <code>nclus.column - 1</code>
independent parameters, and the row coefficients will have <code>n-1</code>
independent parameters, where n is the number of rows in the original data
matrix, i.e. the maximum value of <code>long.df$ROW</code>.</p>
<p>If you include the interaction term alongside the main effects, i.e.</p>
<p><code>Y ~ COLCLUST + ROW + COLCLUST:ROW</code>, or its equivalent with "*", the
interaction term will have <code>(nclus.column - 1)*(n-1)</code> independent
parameters.</p>
<p>If you instead use the formula <code>Y ~ COLCLUST:ROW</code>, that interaction
coefficient matrix will have <code>nclus.column*n - 1</code> independent parameters.</p>
<p>Any covariate terms included in the formula will be split up by
<code>clustord</code> into the covariates that interact with row clusters, the
covariates that interact with column clusters, and the covariates that do not
interact with row or column clusters.</p>
<p>The number of independent parameters for row-cluster-interacting covariates
will be <code>nclus.row*L</code>, where <code>L</code> is the number of terms involving
row clusters and covariates after any "*" terms have been expanded.</p>
<p>So in this formula, for example,</p>
<p><code>Y ~ ROWCLUST*xr1 + xr2 + ROWCLUST:log(xc1)</code></p>
<p>where xr1 and xr2 are row covariates, and xc1 is a column covariate, the fully
expanded formula would be</p>
<p><code>Y ~ ROWCLUST + xr1 + xr2 + ROWCLUST:xr1 + ROWCLUST:log(xc1)</code></p>
<p>and the terms interacting with <code>ROWCLUST</code> would be <code>ROWCLUST:xr1</code>
and <code>ROWCLUST:log(xc1)</code>, so there would be <code>nclus.row*2</code>
independent coefficients for those covariates.</p>
<p>The number of independent parameters for column-cluster-interacting
covariates will be <code>nclus.column*M</code>, where <code>M</code> is the number of
terms involving column clusters and covariates after any "*" terms have been
expanded.</p>
<p>So this formula, for example,</p>
<p><code>Y ~ I(xr1^2) + COLCLUST*xc1 + COLCLUST:xc2:xc3 + COLCLUST*xr1</code></p>
<p>would be expanded as</p>
<p><code>Y ~ COLCLUST + xr1 + I(xr1^2) + xc1 + COLCLUST:xc1 + COLCLUST:xc2:xc3 + COLCLUST:xr1</code></p>
<p>and the terms interacting with <code>COLCLUST</code> would be <code>COLCLUST:xc1</code>,
<code>COLCLUST:xc2:xc3</code> and <code>COLCLUST:xr1</code>, so there would be
<code>nclus.column*3</code> independent coefficients for those covariates.</p>
<p>The number of independent parameters for covariates that do not interact with
row or column clusters will be the same as the number of those covariate terms,
after any "*" terms have been expanded.</p>
<p>So this formula, for example,</p>
<p><code>Y ~ ROWCLUST*xr1 + xr2 + ROWCLUST:log(xc1) + COLCLUST*xc1</code></p>
<p>would be expanded as</p>
<p><code>Y ~ ROWCLUST +COLCLUST + xr1 + xr2 + xc1 + ROWCLUST:xr1 + ROWCLUST:log(xc1) + COLCLUST:xc1</code>,</p>
<p>so there would be 3 independent coefficients for the terms <code>xr1, xr2, xc1</code>.</p>
<p>Note that there are <strong>no intercept</strong> terms for the coefficients,
because those are incorporated into the parameters <code>mu_k</code>.</p>
<p>The <strong>order of the</strong> <code>initvect</code> <strong>entries</strong> is as follows, and
any entries that are not included in the formula will be ignored and not
included in <code>initvect</code>. That is, you should NOT provide values in
<code>initvect</code> for components that are not included in the formula.</p>
<p>1) mu (or values used to construct mu, POM only)
2) values used to construct phi (OSM only)
3) row cluster coefficients
4) column cluster coefficients
5) [matrix] bicluster coefficients (i.e. interaction between row and column clusters)
6) individual row coefficients
7) individual column coefficients
8) [matrix] interactions between row clusters and individual column coefficients
9) [matrix] interactions between column clusters and individual row coefficients
10) [matrix] row-cluster-specific coefficients for covariates interacting with row clusters
11) [matrix] column-cluster-specific coefficients for covariates interacting with column clusters
12) coefficients for covariates that do not interact with row or column clusters</p>
<p>Any entries marked as [matrix] will be constructed into matrices by filling
those matrices row-wise, e.g. if you want starting values 1:6 for a matrix of
2 row clusters and 3 covariates interacting with those row clusters, the
matrix of coefficients will become</p>
<p><code>1 2 3
4 5 6</code></p>
<p>For the formula <code>Y ~ ROWCLUST*COLCLUST</code>, where the matrix of interactions
between row and column clusters has <code>(nclus.row - 1)*(nclus.column - 1)</code>
independent parameters, the last row and column of the matrix will be the
negative sums of the rest, so e.g. if you have 2 row clusters and 3 column
clusters, there will only be 2 independent values, so if you provide the
starting values -0.5 and 1.2, the final matrix of parameters will be:</p>
<p><code>                column cluster 1   column cluster 2   column cluster 3
row cluster 1   -0.5               1.2                -0.7
row cluster 2   0.5                -1.2               0.7</code></p>
<p>If the matrix is a matrix relating to row clusters, then the row clusters are
in the rows, and if it's a matrix relating to column clusters but not row
clusters, then the column clusters are in the rows, i.e. the matrix of
coefficients for column clusters interacting with individual row effects will
have the rows of the matrix corresponding to the clusters, i.e. the matrix
would be indexed colc_row_coef_ci, c being the column cluster index and i
being the row index.</p>
<p>Similarly, if the matrix is a matrix relating to column clusters and covariates,
then the rows of the matrix will correspond to the column clusters, i.e. the
matrix would be indexed colc_cov_coef_cl, c being the column cluster index
and l being the covariate index.</p>
<p>If using biclustering with interaction between row and column clusters, then
the row clusters will be the rows and the column clusters will be the columns,
i.e. the matrix would be indexed rowc_colc_coef_rc, r being the row cluster
index and c being the column cluster index.</p>
    </div>
    <div class="section level2">
    <h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a></h2>
    <p>Fernandez, D., Arnold, R., &amp; Pledger, S. (2016). Mixture-based clustering for the ordered stereotype model. <em>Computational Statistics &amp; Data Analysis</em>, 93, 46-75.</p>
<p>Anderson, J. A. (1984). Regression and ordered categorical variables. <em>Journal of the Royal Statistical Society: Series B (Methodological)</em>, 46(1), 1-22.</p>
<p>Agresti, A. (2010). <em>Analysis of ordinal categorical data</em> (Vol. 656). John Wiley &amp; Sons.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">long.df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>Y<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,<span class="fl">5</span><span class="op">*</span><span class="fl">20</span>,replace<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>               ROW<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">20</span>,times<span class="op">=</span><span class="fl">5</span><span class="op">)</span><span class="op">)</span>,COL<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span>,each<span class="op">=</span><span class="fl">20</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Model Log(P(Y=k)/P(Y=1))=mu_k+phi_k*rowc_coef_r with 3 row clustering groups:</span></span></span>
<span class="r-in"><span><span class="fu">clustord</span><span class="op">(</span><span class="va">Y</span><span class="op">~</span><span class="va">ROWCLUST</span>,model<span class="op">=</span><span class="st">"OSM"</span>,<span class="fl">3</span>,long.df<span class="op">=</span><span class="va">long.df</span>,</span></span>
<span class="r-in"><span>             EM.control<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>EMcycles<span class="op">=</span><span class="fl">2</span>,startEMcycles<span class="op">=</span><span class="fl">2</span><span class="op">)</span>, nstarts<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Converting factor ROW to numeric.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Randomly generated start #1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Found better incomplete log-like: -110.223835125182 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Randomly generated start #2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Found better incomplete log-like: -109.564729537795 </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> EM algorithm has not converged. Please try again, or with a different random seed, or with more starting points.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Call:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> clustord(formula = Y ~ ROWCLUST, model = "OSM", nclus.row = 3, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     long.df = long.df, EM.control = list(EMcycles = 2, startEMcycles = 2), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nstarts = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Clustering mode:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  row clustering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Converged:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Cluster sizes:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Row clusters:  2 18 0 </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Model Log(P(Y=k)/P(Y=1))=mu_k+phi_k*(rowc_coef_r + col_coef_j) with 3 row clustering groups:</span></span></span>
<span class="r-in"><span><span class="fu">clustord</span><span class="op">(</span><span class="va">Y</span><span class="op">~</span><span class="va">ROWCLUST</span><span class="op">+</span><span class="va">COL</span>,model<span class="op">=</span><span class="st">"OSM"</span>,<span class="fl">3</span>,long.df<span class="op">=</span><span class="va">long.df</span>,</span></span>
<span class="r-in"><span>             EM.control<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>EMcycles<span class="op">=</span><span class="fl">2</span>,startEMcycles<span class="op">=</span><span class="fl">2</span><span class="op">)</span>, nstarts<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Converting factor ROW to numeric.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Randomly generated start #1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Using the output of simpler model as initial values for full model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> === End of initial row-cluster-only model fitting ===</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Found better incomplete log-like: -108.357375627435 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Randomly generated start #2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Using the output of simpler model as initial values for full model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> === End of initial row-cluster-only model fitting ===</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Found better incomplete log-like: -108.337761122701 </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> EM algorithm has not converged. Please try again, or with a different random seed, or with more starting points.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Call:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> clustord(formula = Y ~ ROWCLUST + COL, model = "OSM", nclus.row = 3, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     long.df = long.df, EM.control = list(EMcycles = 2, startEMcycles = 2), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nstarts = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Clustering mode:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  row clustering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Converged:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Cluster sizes:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Row clusters:  0 3 17 </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Model Logit(P(Y &lt;= k))=mu_k-rowc_coef_r-col_coef_j-rowc_col_coef_rj with 2 row clustering groups:</span></span></span>
<span class="r-in"><span><span class="fu">clustord</span><span class="op">(</span><span class="va">Y</span><span class="op">~</span><span class="va">ROWCLUST</span><span class="op">*</span><span class="va">COL</span>,model<span class="op">=</span><span class="st">"POM"</span>,nclus.row<span class="op">=</span><span class="fl">2</span>,long.df<span class="op">=</span><span class="va">long.df</span>,</span></span>
<span class="r-in"><span>             EM.control<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>EMcycles<span class="op">=</span><span class="fl">2</span>,startEMcycles<span class="op">=</span><span class="fl">2</span><span class="op">)</span>, nstarts<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Converting factor ROW to numeric.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Randomly generated start #1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Using the output of simpler model as initial values for full model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> === End of initial row-cluster-only model fitting ===</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Using the output of intermediate model as initial values for full model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> === End of intermediate rowcluster-column model fitting ===</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Found better incomplete log-like: -108.74422639491 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Randomly generated start #2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Using the output of simpler model as initial values for full model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> === End of initial row-cluster-only model fitting ===</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Using the output of intermediate model as initial values for full model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> === End of intermediate rowcluster-column model fitting ===</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Found better incomplete log-like: -108.734320154894 </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> EM algorithm has not converged. Please try again, or with a different random seed, or with more starting points.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Call:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> clustord(formula = Y ~ ROWCLUST * COL, model = "POM", nclus.row = 2, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     long.df = long.df, EM.control = list(EMcycles = 2, startEMcycles = 2), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nstarts = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Clustering mode:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  row clustering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Converged:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Cluster sizes:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Row clusters:  20 0 </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Model Log(P(Y=k)/P(Y=1))=mu_k+phi_k*(colc_coef_c) with 3 column clustering groups:</span></span></span>
<span class="r-in"><span><span class="fu">clustord</span><span class="op">(</span><span class="va">Y</span><span class="op">~</span><span class="va">COLCLUST</span>,model<span class="op">=</span><span class="st">"OSM"</span>,nclus.column<span class="op">=</span><span class="fl">3</span>,long.df<span class="op">=</span><span class="va">long.df</span>,</span></span>
<span class="r-in"><span>             EM.control<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>EMcycles<span class="op">=</span><span class="fl">2</span>,startEMcycles<span class="op">=</span><span class="fl">2</span><span class="op">)</span>, nstarts<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Converting factor ROW to numeric.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Randomly generated start #1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Found better incomplete log-like: -109.524420500131 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Randomly generated start #2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Found better incomplete log-like: -109.492519156351 </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> EM algorithm has not converged. Please try again, or with a different random seed, or with more starting points.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Call:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> clustord(formula = Y ~ COLCLUST, model = "OSM", nclus.column = 3, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     long.df = long.df, EM.control = list(EMcycles = 2, startEMcycles = 2), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nstarts = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Clustering mode:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  column clustering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Converged:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Cluster sizes:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Column clusters:  5 0 0 </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Model Log(P(Y=k)/P(Y=1))=mu_k+phi_k*(colc_coef_c + row_coef_i) with 3 column clustering groups:</span></span></span>
<span class="r-in"><span><span class="fu">clustord</span><span class="op">(</span><span class="va">Y</span><span class="op">~</span><span class="va">COLCLUST</span><span class="op">+</span><span class="va">ROW</span>,model<span class="op">=</span><span class="st">"OSM"</span>,nclus.column<span class="op">=</span><span class="fl">3</span>,long.df<span class="op">=</span><span class="va">long.df</span>,</span></span>
<span class="r-in"><span>             EM.control<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>EMcycles<span class="op">=</span><span class="fl">2</span>,startEMcycles<span class="op">=</span><span class="fl">2</span><span class="op">)</span>, nstarts<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Converting factor ROW to numeric.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Randomly generated start #1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Using the output of simpler model as initial values for full model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> === End of initial row-cluster-only model fitting ===</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Found better incomplete log-like: -167.029916889152 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Randomly generated start #2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Using the output of simpler model as initial values for full model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> === End of initial row-cluster-only model fitting ===</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Found better incomplete log-like: -104.673049751169 </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> EM algorithm has not converged. Please try again, or with a different random seed, or with more starting points.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Call:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> clustord(formula = Y ~ COLCLUST + ROW, model = "OSM", nclus.column = 3, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     long.df = long.df, EM.control = list(EMcycles = 2, startEMcycles = 2), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nstarts = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Clustering mode:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  column clustering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Converged:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Cluster sizes:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Column clusters:  5 0 0 </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Model Log(P(Y=k)/P(Y=1))=mu_k+phi_k*(rowc_coef_r + colc_coef_c)</span></span></span>
<span class="r-in"><span><span class="co">#    with 3 row clustering groups and 2 column clustering groups:</span></span></span>
<span class="r-in"><span><span class="fu">clustord</span><span class="op">(</span><span class="va">Y</span><span class="op">~</span><span class="va">ROWCLUST</span><span class="op">+</span><span class="va">COLCLUST</span>,model<span class="op">=</span><span class="st">"OSM"</span>,nclus.row<span class="op">=</span><span class="fl">3</span>,nclus.column<span class="op">=</span><span class="fl">2</span>,long.df<span class="op">=</span><span class="va">long.df</span>,</span></span>
<span class="r-in"><span>             EM.control<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>EMcycles<span class="op">=</span><span class="fl">2</span><span class="op">)</span>, nstarts<span class="op">=</span><span class="fl">1</span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Converting factor ROW to numeric.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Randomly generated start #1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Using the output of simpler model as initial values for full model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> === End of initial row-cluster-only model fitting ===</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Fitting column-cluster-only model (as row-cluster-only model applied to y with ROW and COL switched), to find starting values for colc_coef and kappa_v</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> === End of initial column-cluster-only model fitting ===</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Found better incomplete log-like: 27.6770593225066 </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> EM algorithm has not converged. Please try again, or with a different random seed, or with more starting points.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Call:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> clustord(formula = Y ~ ROWCLUST + COLCLUST, model = "OSM", nclus.row = 3, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nclus.column = 2, long.df = long.df, EM.control = list(EMcycles = 2), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nstarts = 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Clustering mode:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  biclustering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Converged:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Cluster sizes:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Row clusters:  0 20 0 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Column clusters:  5 0 </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Model Logit(P(Y&lt;=k))=mu_k-rowc_coef_r-colc_coef_c-rowc_colc_coef_rc</span></span></span>
<span class="r-in"><span><span class="co">#    with 2 row clustering groups and 4 column clustering groups, and</span></span></span>
<span class="r-in"><span><span class="co">#    interactions between them:</span></span></span>
<span class="r-in"><span><span class="fu">clustord</span><span class="op">(</span><span class="va">Y</span><span class="op">~</span><span class="va">ROWCLUST</span><span class="op">*</span><span class="va">COLCLUST</span>, model<span class="op">=</span><span class="st">"POM"</span>, nclus.row<span class="op">=</span><span class="fl">2</span>, nclus.column<span class="op">=</span><span class="fl">4</span>,</span></span>
<span class="r-in"><span>             long.df<span class="op">=</span><span class="va">long.df</span>,EM.control<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>EMcycles<span class="op">=</span><span class="fl">2</span><span class="op">)</span>, nstarts<span class="op">=</span><span class="fl">1</span>,</span></span>
<span class="r-in"><span>             start_from_simple_model<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Converting factor ROW to numeric.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Randomly generated start #1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Found better incomplete log-like: -7.02961575657048 </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> EM algorithm has not converged. Please try again, or with a different random seed, or with more starting points.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Call:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> clustord(formula = Y ~ ROWCLUST * COLCLUST, model = "POM", nclus.row = 2, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nclus.column = 4, long.df = long.df, EM.control = list(EMcycles = 2), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     start_from_simple_model = FALSE, nstarts = 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Clustering mode:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  biclustering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Converged:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Cluster sizes:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Row clusters:  0 20 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Column clusters:  0 0 5 0 </span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Louise McMillan, Daniel Fernández Martínez, Ying Cui, Eleni Matechou.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer></div>





  </body></html>

