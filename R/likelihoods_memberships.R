# TODO: EDIT THIS to fetch theta on the fly from Rcpp ----
onemode.membership.pp <- function(long.df, theta, proportions, nelements, row){
    nclus <- length(proportions)
    pp.m <- matrix(NA, nelements, nclus)

    pp.raw <- matrix(log(proportions),nelements,nclus,byrow=T)

    for(idx in 1:nelements){
        for(clus.idx in 1:nclus){
            yvals <- long.df$Y[long.df$ROW==idx]
            if (length(yvals) > 0) {
                if (row) pp.raw[idx,clus.idx] <- pp.raw[idx,clus.idx] + sum(log(diag(theta[clus.idx,,yvals])))
                else pp.raw[idx,clus.idx] <- pp.raw[idx,clus.idx] + sum(log(diag(theta[,clus.idx,yvals])))
            }
        }
    }
    for(idx in 1:nelements) pp.m[idx,] <- pp.raw[idx,] - log(sum(exp(pp.raw[idx,] + min(abs(pp.raw[idx,]))))) + min(abs(pp.raw[idx,]))

    pp.m <- exp(pp.m)
    pp.m <- pp.m/rowSums(pp.m)
    pp.m
}

# TODO: EDIT THIS to fetch theta on the fly from Rcpp ====
twomode.membership.pp <- function(long.df, theta, pi.v, kappa.v, nclus, row) {
    n <- max(long.df$ROW)
    p <- max(long.df$COL)

    if (row) {
        pp.m <- matrix(NA,n,nclus)
        pp.raw <- matrix(log(pi.v),n,nclus,byrow=T)
        for(i in 1:n){
            for(r in 1:nclus){
                for(j in 1:p){
                    yval <- long.df$Y[long.df$ROW==i & long.df$COL==j]
                    if (length(yval) == 1) {
                        term <- sum(kappa.v*theta[r,,yval])
                        pp.raw[i,r] <- pp.raw[i,r] + log(term)
                    }
                }
            }
        }
    } else {
        pp.m <- matrix(NA,p,nclus)
        pp.raw <- matrix(log(kappa.v),p,nclus,byrow=T)
        for(j in 1:p){
            for(c in 1:nclus){
                for(i in 1:n){
                    yval <- long.df$Y[long.df$ROW==i & long.df$COL==j]
                    if (length(yval) == 1) {
                        term <- sum(pi.v*theta[,c,yval])
                        pp.raw[j,c] <- pp.raw[j,c] + log(term)
                    }
                }
            }
        }
    }

    for(idx in 1:nrow(pp.m)) pp.m[idx,] <- pp.raw[idx,]-log(sum(exp(pp.raw[idx,] + min(abs(pp.raw[idx,]))))) + min(abs(pp.raw[idx,]))

    pp.m <- exp(pp.m)
    pp.m <- pp.m/rowSums(pp.m)
    pp.m
}

assignments <- function(pp.m) {
    nelements <- nrow(pp.m)
    nclus <- ncol(pp.m)

    assignments <- vector("list",nclus)
    for (idx in 1:nclus) assignments[[idx]] = (1:nelements)[pp.m[,idx]==apply(pp.m,1,max)]
    assignments
}

# TODO: EDIT THIS to take parvec and model matrices as inputs instead of submodel ====
# rcpparma_Bicluster.IncllApprox, or rcpparma_Bicluster.ll
########## ACTUALLY:
# Either split up this function into separate versions for Rcluster and Bicluster,
# or just get rid of this entirely and just call Rcluster.ll, Bicluster.ll,
# Rcluster.Incll and Bicluster.IncllApprox from clustering.R
# (and call their Rcpp versions instead of R versions)
calc.ll <- function(invect, long.df, y.mat, model, submodel, ppr.m, pi.v, RG,
                    ppc.m=NULL, kappa.v=NULL, CG=NULL, constraint.sum.zero=TRUE,
                    partial=FALSE, SE.calc=FALSE) {
    n <- max(long.df$ROW)
    p <- max(long.df$COL)
    q <- length(levels(long.df$Y))

    # TODO: DELETE THIS -- only unpack parvec inside Rcpp ====
    parlist <- unpack.parvec(invect,model=model,submodel=submodel,
                             n=n,p=p,q=q,RG=RG,CG=CG,constraint.sum.zero=constraint.sum.zero)

    # TODO: DELETE THIS -- only calculate theta on the fly inside Rcpp ====
    this.theta <- calc.theta(parlist,model=model,submodel=submodel)

    if (SE.calc) {
        if (submodel %in% c("rs","rp","rpi")) {
            # TODO: EDIT THIS to instead call rcpparma_RCluster.Incll, and pass in ====
            # parvec and model matrices instead of theta
            Rcluster.Incll(long.df, this.theta, pi.v, RG)
        } else if (submodel %in% c("rc","rci")) {
            # TODO: EDIT THIS to instead call rcpparma_BiCluster.IncllApprox, and ====
            # pass in parvec and model matrices instead of theta
            Bicluster.IncllApprox(long.df=long.df, y.mat=y.mat, theta=this.theta,
                                  ppr.m=ppr.m, ppc.m=ppc.m, pi.v=pi.v, kappa.v=kappa.v)
        }
    } else {
        if (submodel %in% c("rs","rp","rpi")) {
            # TODO: EDIT THIS to instead call rcpparma_RCluster.ll, and pass in ====
            # parvec and model matrices instead of theta
            Rcluster.ll(long.df, y.mat, this.theta, ppr.m, pi.v, RG, partial=partial)
        } else if (submodel %in% c("rc","rci")) {
            # TODO: EDIT THIS to instead call rcpparma_BiCluster.ll, and pass in ====
            # parvec and model matrices instead of theta
            Bicluster.ll(long.df, y.mat, this.theta, ppr.m, ppc.m, pi.v, kappa.v, partial=partial)
        }
    }
}

# TODO: PROBABLY DELETE THIS -- unnecessary, just call Rcpp directly from higher level ====
Rcluster.ll <- function(long.df, y.mat, theta, ppr.m, pi.v, RG, partial=FALSE){
    n <- max(long.df$ROW)
    p <- max(long.df$COL)
    q <- length(levels(long.df$Y))

    theta[theta<=0]=lower.limit
    pi.v[pi.v==0]=lower.limit
    # llc=0
    # for (r in 1:RG) {
    #     # theta.y.mat <- sapply(1:p,function(j) {
    #     #     yvals <- as.numeric(long.df$Y[long.df$COL==j])
    #     #     theta[r,j,yvals]
    #     # }) ## <-- THIS IS VERY VERY SLOW
    #     # llc <- llc + sum(t(ppr.m[,r])%*%log(theta.y.mat))
    #     log.theta.y.mat <- sapply(1:p,function(j) {
    #         raw.log.theta <- log(theta[r,j,y.mat[,j]])
    #         raw.log.theta[is.na(raw.log.theta) | is.infinite(raw.log.theta)] <- 0
    #         raw.log.theta
    #     })
    #     llc <- llc + sum(t(ppr.m[,r])%*%log.theta.y.mat)
    # }
    # if (!partial) llc <- llc + sum(ppr.m%*%log(pi.v))
    #
    # if (!is.finite(llc)) browser()

    llc <- rcpparma_Rclusterll(y.mat, theta, ppr.m, pi.v, RG, p, n, as.numeric(partial))

    llc
}

# TODO: PROBABLY DELETE THIS -- and instead use rcpparma_updateliR or updateliC ====
# (and update them to construct theta on the fly)
Rcluster.Incll <- function(long.df, theta, pi.v, RG)
{
    n <- max(long.df$ROW)
    p <- max(long.df$COL)
    q <- length(levels(long.df$Y))

    theta[theta<=0]=lower.limit
    pi.v[pi.v==0]=lower.limit
    logl = 0
    for(i in 1:n){
        log.components <- rep(0,RG)
        yvals <- long.df$Y[long.df$ROW==i]
        for(r in 1:RG){
            if (length(yvals) >= 1) {
                if (length(yvals) == 1) th <- theta[r,,yvals]
                else if (length(yvals) > 1) th <- diag(theta[r,,yvals])
                log.components[r] <- log(pi.v[r]) + sum(log(th),na.rm=TRUE)
            }
        }
        log.sumoverR <- log(sum(exp(log.components - max(log.components)))) + max(log.components)
        logl <- logl + log.sumoverR
    }
    if (logl == 0) logl <- -1E-40
    logl
}

# TODO: PROBABLY DELETE THIS ====
Bicluster.ll <- function(long.df, y.mat, theta, ppr.m, ppc.m, pi.v, kappa.v, partial=FALSE){
    n <- max(long.df$ROW)
    p <- max(long.df$COL)
    q <- length(levels(long.df$Y))

    RG <- length(pi.v)
    CG <- length(kappa.v)

    theta[theta<=0]=lower.limit
    pi.v[pi.v==0]=lower.limit
    kappa.v[kappa.v==0]=lower.limit

    llc=0

    for (r in 1:RG) {
        for (c in 1:CG) {
            # theta.y <- t(sapply(1:n, function(i) {
            #     sapply(1:p, function(j) {
            #         # theta[r,c,long.df$Y[long.df$ROW==i & long.df$COL==j]] ## <-- THIS IS VERY VERY SLOW
            #         if (is.na(y.mat[i,j])) return(0)
            #         else return(theta[r,c,y.mat[i,j]])
            #     })
            # }))
            # llc <- llc + t(ppr.m[,r])%*%log(theta.y)%*%ppc.m[,c]
            log.theta.y <- t(sapply(1:n, function(i) {
                sapply(1:p, function(j) {
                    if (is.na(y.mat[i,j]) || y.mat[i,j] <= 0) return(0)
                    else return(log(theta[r,c,y.mat[i,j]]))
                })
            }))
            llc <- llc + t(ppr.m[,r])%*%log.theta.y%*%ppc.m[,c]
        }
    }
    if (!partial) {
        llc <- llc + sum(ppr.m%*%log(pi.v))
        llc <- llc + sum(ppc.m%*%log(kappa.v))
    }
    llc
}

#The incomplete log-likelihood,used in model selection#
# TODO: PROBABLY DELETE THIS ====
Bicluster.IncllC <- function(long.df, theta, pi.v, kappa.v)
{
    n <- max(long.df$ROW)
    p <- max(long.df$COL)
    q <- length(levels(long.df$Y))
    RG <- length(pi.v)
    CG <- length(kappa.v)

    theta[theta<=0]=lower.limit
    pi.v[pi.v==0]=lower.limit
    kappa.v[kappa.v==0]=lower.limit

    # Full evaluation using the columns.
    # Use if CG^p is small enough.
    # Construct n*p*RG*CG*q array of Multinomial terms:
    multi.arr = array(NA,c(n,p,RG,CG))
    for(i in 1:n){
        for(j in 1:p){
            for(r in 1:RG){
                for(c in 1:CG){
                    for(k in 1:q){
                        yval <- as.numeric(long.df$Y[long.df$ROW==i & long.df$COL==j])
                        if(length(yval) == 1 && yval==k) multi.arr[i,j,r,c]=theta[r,c,k]
                    }
                }
            }
        }
    }

    combos.mat <- as.matrix(expand.grid(rep(list(1:CG),p)))
    # combos.mat has one row per combination of c selections.
    AA <- nrow(combos.mat)
    Aair.a  <- array(NA,c(AA,n,RG))
    Bair.a  <- array(NA,c(AA,n,RG))
    Bai.m   <- matrix(NA,AA,n)
    Dai.m   <- matrix(NA,AA,n)
    Ea.v    <- rep(NA,AA)
    alpha.v <- rep(NA,AA)
    m.a    <- array(NA,c(n,p,RG))  # Multi. array for current combo
    for (aa in 1:AA)
    {
        # Vector of c selections:
        c.v <- combos.mat[aa,]
        # Find the kappa product:
        alpha.v[aa] <- prod(kappa.v[c.v])
        if (alpha.v[aa]>0)
        {
            # Pick out elements of multi.arr where each col has known CG:
            for (ii in 1:n) for (jj in 1:p) for (rr in 1:RG)
                m.a[ii,jj,rr] <- multi.arr[ii,jj,rr,c.v[jj]]
            # Calculate and store row aa of Aair.a:
            for (ii in 1:n) for (rr in 1:RG)
                Aair.a[aa,ii,rr] <-  log(pi.v[rr]) + sum(log(m.a[ii,,rr]),na.rm=TRUE)

            # May have NA if pi.v[rr]=0, don't use those terms.
            max.Aair <- apply(Aair.a[aa,,],1,max,na.rm=T)

            for (ii in 1:n)
            {
                Bai.m[aa,ii]   <- max.Aair[ii]
                Dai.m[aa,ii]   <- sum(exp(Aair.a[aa,ii,]-max.Aair[ii]))
            }

            Ea.v[aa] <- sum(Bai.m[aa,]) + sum(log(Dai.m[aa,]),na.rm=T)
            Ea.v[aa] <- Ea.v[aa] + log(alpha.v[aa])
        }
    }
    M.val <- max(Ea.v, na.rm=TRUE)
    logl <- M.val + log(sum(exp(Ea.v-M.val),na.rm=TRUE))
    logl
}

# Rows expansion (use if RG^n small enough):
# TODO: PROBABLY DELETE THIS ====
Bicluster.IncllR <- function(long.df, theta, pi.v, kappa.v)
{
    n <- max(long.df$ROW)
    p <- max(long.df$COL)
    q <- length(levels(long.df$Y))
    RG <- length(pi.v)
    CG <- length(kappa.v)

    theta[theta<=0]=lower.limit
    pi.v[pi.v==0]=lower.limit
    kappa.v[kappa.v==0]=lower.limit

    # Full evaluation using the rows.
    # Use if RG^n is small enough.
    # Construct n*p*RG*CG*q array of Multinomial terms:
    multi.arr = array(NA,c(n,p,RG,CG))
    for(i in 1:n){
        for(j in 1:p){
            for(r in 1:RG){
                for(c in 1:CG){
                    for(k in 1:q){
                        yval <- as.numeric(long.df$Y[long.df$ROW==i & long.df$COL==j])
                        if(length(yval)==1 && yval==k) multi.arr[i,j,r,c]=theta[r,c,k]
                    }
                }
            }
        }
    }
    combos.mat <- as.matrix(expand.grid(rep(list(1:RG),n)))
    # combos.mat has one row per combination of r selections.
    AA <- nrow(combos.mat)
    Aajc.a  <- array(NA,c(AA,p,CG))
    Bajc.a  <- array(NA,c(AA,p,CG))
    Baj.m   <- matrix(NA,AA,p)
    Daj.m   <- matrix(NA,AA,p)
    Ea.v    <- rep(NA,AA)
    alpha.v <- rep(NA,AA)
    m.a    <- array(NA,c(n,p,CG))  # Multi. array for current combo
    for (aa in 1:AA)
    {
        # Vector of r selections:
        r.v <- combos.mat[aa,]
        # Find the pi product:
        alpha.v[aa] <- prod(pi.v[r.v])
        if (alpha.v[aa]>0)
        {
            # Pick out elements of multi.arr where each row has known RG:
            for (ii in 1:n) for (jj in 1:p) for (cc in 1:CG)
                m.a[ii,jj,cc] <- multi.arr[ii,jj,r.v[ii],cc]
            # Calculate and store row aa of Aair.a:
            for (jj in 1:p) for (cc in 1:CG)
                Aajc.a[aa,jj,cc] <-  log(kappa.v[cc]) + sum(log(m.a[,jj,cc]),na.rm=TRUE)
            # May have NA if kappa.v[cc]=0, don't use those terms.
            max.Aajc <- apply(Aajc.a[aa,,],1,max,na.rm=T)

            for (jj in 1:p)
            {
                Baj.m[aa,jj]   <- max.Aajc[jj]
                Daj.m[aa,jj]   <- sum(exp(Aajc.a[aa,jj,]-max.Aajc[jj]))
            }

            Ea.v[aa] <- sum(Baj.m[aa,]) + sum(log(Daj.m[aa,]),na.rm=T)
            Ea.v[aa] <- Ea.v[aa] + log(alpha.v[aa])
        }
    }
    M.val <- max(Ea.v, na.rm=TRUE)
    logl <- M.val + log(sum(exp(Ea.v-M.val),na.rm=TRUE))
    logl
}

# TODO: PROBABLY DELETE THIS - INSTEAD JUST USE RCPP FUNCTION ====
## Biclustering incomplete-data log-likelihood calculated based on the approximation
## relating the incomplete-data and complete-data log-likelihoods
Bicluster.IncllApprox <- function(llc=NULL, long.df, y.mat, theta, pi.v, kappa.v, ppr.m, ppc.m) {
    n <- max(long.df$ROW)
    p <- max(long.df$COL)
    q <- length(levels(long.df$Y))
    RG <- length(pi.v)
    CG <- length(kappa.v)

    theta[theta<1E-40]=lower.limit
    pi.v[pi.v<1E-40]=lower.limit
    kappa.v[kappa.v<1E-40]=lower.limit

    if (is.null(llc)) llc <- Bicluster.ll(long.df, y.mat, theta, ppr.m, ppc.m, pi.v, kappa.v, partial=FALSE)

    llc.correction.term <- 0

    for (i in 1:n) {
        for (j in 1:p) {
            if (!is.na(y.mat[i,j]) && y.mat[i,j] > 0) {
                theta.ij <- theta[,,y.mat[i,j]]
                ## Multiply every row by the corresponding value of pi.v, i.e.
                ## multiply pi.v down each column, and multiply kappa.v across
                ## each row
                denom <- t(apply(apply(theta.ij,2,"*",pi.v),1,"*",kappa.v))
                tau.ij <- denom/sum(denom)
                log.tau.ij <- log(tau.ij)

                ## Now do the following calculation in stages, and to avoid Inf*0 = NaN
                ## forcibly convert any related infinite terms to 0
                part1 <- ppr.m[i,]%*%log.tau.ij
                if (any(is.na(part1))) {
                    na.idxs <- which(is.na(part1))
                    for (idx in na.idxs) {
                        log.tau.ij[is.infinite(log.tau.ij[,idx]),idx] <- 0
                    }
                    part1 <- ppr.m[i,]%*%log.tau.ij
                }
                part2 <- part1%*%ppc.m[j,]
                if (is.na(part2)) {
                    part1[is.infinite(part1)] <- 0
                    part2 <- part1%*%ppc.m[j,]
                }
                if (is.na(part2)) browser()
                llc.correction.term <- llc.correction.term + part2
                # if (is.na(ppr.m[i,]%*%log(tau.ij)%*%ppc.m[j,])) browser()
                # llc.correction.term <- llc.correction.term + ppr.m[i,]%*%log(tau.ij)%*%ppc.m[j,]
            }
        }
    }

    if (is.finite(llc.correction.term)) lli <- llc - llc.correction.term
    else lli <- -Inf
}
